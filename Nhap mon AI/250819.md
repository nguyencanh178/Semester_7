## Bài toán quân hậu

-> Đích không tường minh do trên bàn cờ có sẵn 8 quân hậu bất kì và 8 quân sắp ngẫu nhiên di chuyển các quân cờ sao cho không ăn được nhau, số tổ hợp 8C64 (lấy 8 ô ngẫu nhiên trong 64 ô và đặt các quân hậu vào vị trí)

## Cây tìm kiếm

**Ý tưởng chung:** Xem xét các trạng thái 

Search (Q, S, G, P)

(Q: Không gian trạng thái, S: trạng thái bắt đầu, G: đích, P: hành động)

Đầu vào: Bài toán tìm kiếm với 4 tp như trên
Đầu ra: trạng thái đích

```c
# define O <- S
while (O != emty){
    1. Chọn nút n thuộc 0 và xóa n khỏi O
    2. 
    3.
} 
```
**Chiến lược tìm kiếm được xác định bởi thứ tự mở rộng các nút trên cây tìm kiếm**

### Tìm kiếm mù (Tìm kiếm không có thông tin)

#### Tìm kiếm theo chiều rộng - BFS

**Nguyên tắc:** trong số các nút biên, lựa chọn các nút nông nhất (gần gốc nhất) để mở rộng

Ghi nhớ đường đi:

- Khi mở rộng một nút, ta cần sử dụng **con trỏ ngược** để ghi lại nút cha của nút vừa mở ra

**BFS(Q, S, G, P)**

>- Input: Bài toán tìm kiếm
>- Output: Trạng thái đích

```c
Khởi tạo: O <- S 
while (O != emty) do:
    1. Lấy nút đầu tiên n khỏi O
    2. if m thuộc G, return (đường đi tới n)
    3. thêm P(n) vào đuôi O (Sử dụng **FIFO**)
return: Không tìm được đường đi
```

**Tránh các nút lặp**

- Có thể có nhiều đường đi cùng dẫn tới một nút
    - Thuật toán có thể mở rộng một nút nhiều lần
    - Có thể dẫn tới vòng lặp vô hạn
- Giải pháp:
    - Không thêm nút vào hàng đội để nút đã được duyệt hoặc đang nằm trong hàng đợi
    - Cần nhớ ít nút, tgian kiểm tra nhanh, tránh được vòng lặp vô hạn

**Tính chất BFS**

- Thuật toán có tính đầy đủ, tức là nếu bài toán có lời giải, tìm kiếm theo chiều rộng đảm bảo tìm ra lời giải.

- Tính tối ưu: thuật toán đảm bảo tìm ra lời giải có độ sâu nhỏ nhất.

- Thời gian: 1 + b + b^2 + ... + b^d = O(b^d)

- Bộ nhớ: O(b^d) (lưu tất cả các nút)

### Tìm kiếm theo giá thành thống nhất UCS (biến thể BFS)

- Phương pháp chọn nút có giá nhỏ nhất để mở rộng trước thay vì chọn nút công nhất như trong BFS

```c
1. Chọn nút n có giá thành g(n) nhỏ nhất thuộc O và xóa n khỏi O 
2. If n ∈ G, return (đường đi tới n) 
3. Thêm P(n) và giá thành đường đi tới n  (g(n)) vào O
```